<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ğŸ¤ Gemini AI ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œå‡º</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        .main-container { position: relative; display: inline-block; }
        #video-container { position: relative; margin: 20px auto; width: 640px; height: 480px; }

        #video-feed { width: 100%; height: 100%; object-fit: cover; }

        /* æ¤œå‡ºçµæœã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        #overlay-canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 10;
            pointer-events: none;
        }

        #command-output {
            margin-top: 10px;
            font-size: 1.2em;
            font-weight: bold;
            min-height: 2em;
        }

        .status { padding: 5px 10px; border-radius: 5px; margin-right: 10px; }
        .status.listening { background-color: #f7d794; }
        .status.analyzing { background-color: #00796b; color: white; }
        #capture-canvas { display: none; }
    </style>
</head>
<body>
    <h1>Gemini AIã«ã‚ˆã‚‹ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç”»åƒè§£æ</h1>

    <div id="status-area">
        <span id="mic-status" class="status">ãƒã‚¤ã‚¯: å¾…æ©Ÿä¸­</span>
        <span id="analysis-status" class="status">è§£æ: åœæ­¢ä¸­</span>
    </div>

    <p id="command-output">æŒ‡ç¤º: ã€Œã™ã¹ã¦æ¤œå‡ºã€</p>

    <div id="manual-input-area" style="margin-bottom: 20px;">
        <input type="text" id="manual-command-input" placeholder="ãƒ†ã‚¹ãƒˆç”¨æŒ‡ç¤ºã‚’å…¥åŠ› (ä¾‹: èµ¤ã„è»Š)" size="50">
        <button onclick="setManualCommand()">æŒ‡ç¤ºã‚’é©ç”¨</button>
        <button onclick="startVoiceCommand()">éŸ³å£°æŒ‡ç¤ºã«æˆ»ã™</button>
    </div>
    <div class="main-container">
        <div id="video-container">
            <video id="video-feed" autoplay playsinline></video>
            <canvas id="overlay-canvas"></canvas>
        </div>
        <canvas id="capture-canvas"></canvas>
    </div>

    <script>
        const video = document.getElementById('video-feed');
        const overlayCanvas = document.getElementById('overlay-canvas');
        const captureCanvas = document.getElementById('capture-canvas');
        const commandOutput = document.getElementById('command-output');
        const micStatus = document.getElementById('mic-status');
        const analysisStatus = document.getElementById('analysis-status');

        const FRAME_RATE = 1000; // è§£æé–“éš” (ãƒŸãƒªç§’)ã€‚
        const WIDTH = 640;
        const HEIGHT = 480;

        let recognition;
        let currentCommand = "ã™ã¹ã¦æ¤œå‡º"; // åˆæœŸã‚³ãƒãƒ³ãƒ‰
        let isAnalyzing = false;

        // --- åˆ¶å¾¡é–¢æ•° ---
        function setManualCommand() {
            const inputElement = document.getElementById('manual-command-input');
            const newCommand = inputElement.value.trim();

            if (newCommand) {
                currentCommand = newCommand;
                commandOutput.textContent = `æ‰‹å‹•æŒ‡ç¤º: ã€Œ${newCommand}ã€`;
                stopRecognition();
            } else {
                alert("æŒ‡ç¤ºã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
            }
        }

        function startVoiceCommand() {
            // éŸ³å£°æŒ‡ç¤ºã®é–‹å§‹ï¼ˆæ—¢å­˜ã®é–¢æ•°ã‚’å†åˆ©ç”¨ï¼‰
            startRecognition();
            commandOutput.textContent = `éŸ³å£°æŒ‡ç¤º: å¾…æ©Ÿä¸­`;
            document.getElementById('manual-command-input').value = "";
        }

        function stopRecognition() {
            if (recognition) {
                recognition.onend = null; // è‡ªå‹•å†èµ·å‹•ã‚’é˜²ã
                recognition.stop();
                micStatus.textContent = 'ãƒã‚¤ã‚¯: æ‰‹å‹•åœæ­¢';
                micStatus.className = 'status';
            }
        }

        // --- 1. ã‚«ãƒ¡ãƒ©ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹ã®åˆæœŸè¨­å®š ---
        function setupCamera() {
            navigator.mediaDevices.getUserMedia({ video: { width: WIDTH, height: HEIGHT } })
                .then(stream => {
                    video.srcObject = stream;
                    video.onloadedmetadata = () => {
                        video.play();
                        overlayCanvas.width = WIDTH;
                        overlayCanvas.height = HEIGHT;
                        captureCanvas.width = WIDTH;
                        captureCanvas.height = HEIGHT;
                        startRecognition(); // ã‚«ãƒ¡ãƒ©èµ·å‹•å¾Œã«éŸ³å£°èªè­˜ã‚’é–‹å§‹
                        startAnalysisLoop(); // ã‚«ãƒ¡ãƒ©èµ·å‹•å¾Œã«è§£æãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
                    };
                })
                .catch(err => {
                    alert('ã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒå¿…è¦ã§ã™: ' + err);
                });
        }

        // --- 2. éŸ³å£°èªè­˜ ---
        function startRecognition() {
            window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                micStatus.textContent = 'ãƒã‚¤ã‚¯: éå¯¾å¿œ';
                return;
            }

            // æ—¢ã«èªè­˜ãŒå‹•ã„ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯ (äºŒé‡èµ·å‹•é˜²æ­¢)
            if (recognition && micStatus.textContent === 'ãƒã‚¤ã‚¯: è´å–ä¸­') return;

            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = false;
            recognition.lang = 'ja-JP';

            recognition.onstart = () => {
                micStatus.textContent = 'ãƒã‚¤ã‚¯: è´å–ä¸­';
                micStatus.className = 'status listening';
            };

            recognition.onresult = (event) => {
                const transcript = event.results[event.results.length - 1][0].transcript;
                currentCommand = transcript;
                commandOutput.textContent = `éŸ³å£°æŒ‡ç¤º: ã€Œ${transcript}ã€`;
            };

            recognition.onend = () => {
                // æ‰‹å‹•åœæ­¢ã§ãªã‘ã‚Œã°ã€è‡ªå‹•ã§å†èµ·å‹•ã™ã‚‹
                if (micStatus.textContent !== 'ãƒã‚¤ã‚¯: æ‰‹å‹•åœæ­¢') {
                    micStatus.textContent = 'ãƒã‚¤ã‚¯: å¾…æ©Ÿä¸­';
                    micStatus.className = 'status';
                    setTimeout(startRecognition, 100);
                }
            };

            recognition.onerror = (event) => {
                console.error('Recognition error:', event.error);
                micStatus.textContent = `ãƒã‚¤ã‚¯: ã‚¨ãƒ©ãƒ¼ (${event.error})`;
            };

            recognition.start();
        }

        // --- 3. è§£æãƒ«ãƒ¼ãƒ—ã¨ãƒ•ãƒ¬ãƒ¼ãƒ é€ä¿¡ ---
        function startAnalysisLoop() {
            setInterval(captureAndAnalyze, FRAME_RATE);
            analysisStatus.textContent = 'è§£æ: å‹•ä½œä¸­';
            analysisStatus.className = 'status analyzing';
        }

        function captureAndAnalyze() {
            if (isAnalyzing || !video.srcObject) {
                return;
            }

            isAnalyzing = true;
            const ctx = captureCanvas.getContext('2d');
            ctx.drawImage(video, 0, 0, WIDTH, HEIGHT);

            const imageDataURL = captureCanvas.toDataURL('image/jpeg', 0.6);

            fetch('/analyze_frame', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ image: imageDataURL, command: currentCommand })
            })
            .then(response => response.json())
            .then(data => {
                isAnalyzing = false;
                if (data.success) {
                    drawDetections(data.detections);
                } else {
                    console.error('Analysis error:', data.error);
                }
            })
            .catch(error => {
                isAnalyzing = false;
                console.error('Fetch error:', error);
            });
        }

        // --- 4. æ¤œå‡ºçµæœã®æç”» (å¯¾è±¡ç‰©ä»¥å¤–ã‚’æš—ãã™ã‚‹ãƒã‚¤ãƒ©ã‚¤ãƒˆå‡¦ç†ã‚’è¿½åŠ ) ---
function drawDetections(detections) {
    const ctx = overlayCanvas.getContext('2d');
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // 1. å…¨ä½“ã‚’æš—ãã™ã‚‹ãƒ‡ã‚£ãƒ ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æç”»
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // åŠé€æ˜ã®é»’
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // 2. ãã‚ŠæŠœãã®è¨­å®š (é‡è¦!)
    // æ¬¡ã«æç”»ã™ã‚‹å›³å½¢ãŒã€æ—¢å­˜ã®æç”»å†…å®¹ã‚’æ¶ˆå»ã™ã‚‹ã‚ˆã†ã«è¨­å®šã—ã¾ã™
    ctx.globalCompositeOperation = 'destination-out';

    detections.forEach(d => {
        const [x_min_norm, y_min_norm, x_max_norm, y_max_norm] = d.box;

        // æ­£è¦åŒ–åº§æ¨™ (0.0-1.0) ã‚’ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã«å¤‰æ›
        const x_min = x_min_norm * WIDTH;
        const y_min = y_min_norm * HEIGHT;
        const width = (x_max_norm - x_min_norm) * WIDTH;
        const height = (y_max_norm - y_min_norm) * HEIGHT;

        // 3. æ¤œå‡ºã•ã‚ŒãŸé ˜åŸŸã‚’ä¸é€æ˜ãªè‰²ã§æç”»ã—ã€ä¸‹ã®ãƒ‡ã‚£ãƒ ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãã‚ŠæŠœã
        // ãã‚ŠæŠœãå‡¦ç†ã§ã¯è‰²ã¯ä½•ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ (ã“ã“ã§ã¯ç™½ã‚’ä½¿ç”¨)
        ctx.fillStyle = 'white';
        ctx.fillRect(x_min, y_min, width, height);
    });

    // 4. åˆæˆãƒ¢ãƒ¼ãƒ‰ã‚’å…ƒã«æˆ»ã™ (ä»¥é™ã®æç”»ãŒä¸Šæ›¸ãã«ãªã‚‹ã‚ˆã†ã«)
    ctx.globalCompositeOperation = 'source-over';

    // 5. æ ç·šã¨ãƒ©ãƒ™ãƒ«ã®æç”» (ãã‚ŠæŠœã„ãŸç©´ã®ä¸Šã«æç”»)
    detections.forEach(d => {
        const color = d.color_hex || '#FFC107';
        const [x_min_norm, y_min_norm, x_max_norm, y_max_norm] = d.box;

        const x_min = x_min_norm * WIDTH;
        const y_min = y_min_norm * HEIGHT;
        const width = (x_max_norm - x_min_norm) * WIDTH;
        const height = (y_max_norm - y_min_norm) * HEIGHT;

        // æ ç·šã®æç”»
        ctx.strokeStyle = color;
        ctx.lineWidth = 4;
        ctx.strokeRect(x_min, y_min, width, height);

        // ãƒ©ãƒ™ãƒ«ã®æç”» (èƒŒæ™¯)
        const labelText = `${d.name} | ${color}`;
        ctx.font = 'bold 16px Arial';
        const textMetrics = ctx.measureText(labelText);

        ctx.fillStyle = color;
        ctx.fillRect(x_min, y_min - 20, textMetrics.width + 10, 20);

        // ãƒ©ãƒ™ãƒ«ã®æç”» (æ–‡å­—)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillText(labelText, x_min + 5, y_min - 5);
    });
}

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        setupCamera();
    </script>
</body>
</html>